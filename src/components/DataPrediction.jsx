import Layout from '../layout/Layout';
import { Container, Typography, Grid, Paper, Box } from '@mui/material';
import { useState } from 'react';
import fieldConfigs from './fieldConfigs';
import HelpSidebar from './HelpSidebar';
import PredictionForm from './PredictionForm';
import ResultDialog from './ResultDialog';
import NavigationButtons from './NavigationButtons';
import { BASE_URL } from './Constant';
import { jsPDF } from 'jspdf';

export default function DataPrediction() {
    const initial = fieldConfigs.reduce((o, f) => ({ ...o, [f.name]: '' }), {});
    const [features, setFeatures] = useState(initial);
    const [model, setModel] = useState('logistic_regression');
    const [errors, setErrors] = useState({});
    const [loading, setLoading] = useState(false);
    const [result, setResult] = useState(null);
    const [open, setOpen] = useState(false);
    const [hoveredField, setHoveredField] = useState(null);

    const validateField = (name, value) => {
        const cfg = fieldConfigs.find(f => f.name === name);
        if (value === '') return 'Required';
        if (cfg.inputType === 'number') {
            const num = Number(value);
            if (isNaN(num)) return 'Must be a number';
            if (num < cfg.min || num > cfg.max) return `${cfg.label} must be between ${cfg.min} and ${cfg.max}`;
        }
        return '';
    };

    const handleChange = e => {
        const { name, value } = e.target;
        setFeatures(f => ({ ...f, [name]: value }));
        setErrors(errs => ({ ...errs, [name]: '' }));
        setResult(null);
    };

    const handleBlur = e => {
        const { name, value } = e.target;
        setErrors(errs => ({ ...errs, [name]: validateField(name, value) }));
    };

    const handleSubmit = async e => {
        e.preventDefault();
        const newErrs = {};
        fieldConfigs.forEach(({ name }) => {
            const err = validateField(name, features[name]);
            if (err) newErrs[name] = err;
        });
        if (Object.keys(newErrs).length) {
            setErrors(newErrs);
            return;
        }

        setLoading(true);
        try {
            const payload = {};
            Object.entries(features).forEach(([k, v]) => {
                const cfg = fieldConfigs.find(f => f.name === k);
                payload[k] = cfg.inputType === 'number' ? Number(v) : v;
            });

            const res = await fetch(`${BASE_URL}/api/${model}/predict`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const json = await res.json();
            setResult({ ...json, inputs: payload });
            setOpen(true);
        } catch (err) {
            setResult({ error: err.message, inputs: features });
            setOpen(true);
        } finally {
            setLoading(false);
        }
    };

    const handleClose = () => {
        setOpen(false);
        setFeatures(initial);
        setErrors({});
        setResult(null);
        setHoveredField(null);
    };

    const handleDownloadPdf = () => {
        if (!result || result.error) return;
        const doc = new jsPDF();
        doc.setFillColor(33, 150, 243);
        doc.rect(0, 0, 210, 20, 'F');
        doc.setTextColor(255, 255, 255);
        doc.setFontSize(16);
        doc.text('Heart Disease Prediction Report', 105, 14, { align: 'center' });
        doc.setTextColor(0, 0, 0);
        doc.setFontSize(12);
        doc.text(`Name: ${result.inputs.name}`, 10, 30);
        doc.text(`Model: ${model.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase())}`, 10, 38);
        doc.text(`Prediction: ${result.prediction === 1 ? 'High likelihood of disease' : 'Low likelihood of disease'}`, 10, 46);
        doc.text(`Risk score: ${(result.probability?.[1] ?? 0 * 100).toFixed(1)}% positive`, 10, 54);
        let y = 70;
        doc.setFontSize(11);
        doc.text('Inputs:', 10, y);
        y += 8;
        Object.entries(result.inputs).forEach(([k, v]) => {
            const cfg = fieldConfigs.find(f => f.name === k);
            let display = v;
            if (cfg.inputType === 'select') {
                display = cfg.options.find(o => o.value === Number(v))?.label;
            }
            doc.text(`${cfg.label}: ${display}`, 10, y);
            y += 6;
            if (y > 280) {
                doc.addPage();
                y = 20;
            }
        });
        const pageCount = doc.getNumberOfPages();
        for (let i = 1; i <= pageCount; i++) {
            doc.setPage(i);
            doc.setFillColor(33, 150, 243);
            doc.rect(0, 287, 210, 10, 'F');
            doc.setTextColor(255, 255, 255);
            doc.setFontSize(10);
            doc.text(`Generated by © 2025 IITJ - MINING HOSPITAL RECORDS FOR PREDICTING HEART PATIENT DROP-OFF – Page ${i}/${pageCount}`, 105, 293, { align: 'center' });
        }
        doc.save(`${result.inputs.name || 'report'}.pdf`);
    };

    return (
        <Layout>
            <Container
                maxWidth={false}
                disableGutters
                sx={{
                    py: 4,
                    px: { xs: 2, md: 4 },
                    background: 'linear-gradient(135deg, #e3f2fd 30%, #ffffff 100%)',
                    minHeight: '100vh'
                }}
            >
                {/* Page Title */}
                <Typography
                    variant="h4"
                    gutterBottom
                    sx={{
                        fontWeight: 'bold',
                        textAlign: 'center',
                        mb: 4,
                        color: 'primary.main'
                    }}
                >
                    Heart Disease Predictor
                </Typography>

                {/* Main Form + Sidebar */}
                <Grid container spacing={4}>
                    {/* Form */}
                    <Grid item xs={12} md={8}>
                        <PredictionForm
                            features={features}
                            errors={errors}
                            model={model}
                            setModel={setModel}
                            handleChange={handleChange}
                            handleBlur={handleBlur}
                            handleSubmit={handleSubmit}
                            loading={loading}
                            setHoveredField={setHoveredField}
                            setResult={setResult}
                        />
                    </Grid>

                    {/* Sidebar */}
                    <Grid item xs={12} md={4}>
                        <Paper elevation={3} sx={{ p: 2, borderRadius: 3, backgroundColor: '#fafafa' }}>
                            <HelpSidebar hoveredField={hoveredField} />
                        </Paper>
                    </Grid>
                </Grid>

                {/* Result Dialog */}
                {result && (
                    <ResultDialog
                        open={open}
                        result={result}
                        handleClose={handleClose}
                        handleDownloadPdf={handleDownloadPdf}
                    />
                )}

                {/* Navigation Buttons */}
                <NavigationButtons />

                <br /><br />
            </Container>
        </Layout>
    );
}
